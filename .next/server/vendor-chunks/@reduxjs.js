"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign((...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction getOrInsertComputed(map, key, compute) {\n    if (map.has(key)) return map.get(key);\n    return map.set(key, compute(key)).get(key);\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\n             false ? 0 : createQueueWithTimer(10) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, duplicateMiddlewareCheck = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if ( true && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if ( true && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if ( true && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    if ( true && duplicateMiddlewareCheck) {\n        let middlewareReferences = /* @__PURE__ */ new Set();\n        finalMiddleware.forEach((middleware2)=>{\n            if (middlewareReferences.has(middleware2)) {\n                throw new Error( false ? 0 : \"Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.\");\n            }\n            middlewareReferences.add(middleware2);\n        });\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: \"development\" !== \"production\",\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if ( true && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if ( true && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if ( true && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addAsyncThunk (asyncThunk, reducers) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;\n            if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;\n            if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;\n            if (reducers.settled) actionMatchers.push({\n                matcher: asyncThunk.settled,\n                reducer: reducers.settled\n            });\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return isAllOf(isRejected(...asyncThunks), hasFlag);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return isAnyOf(...asyncThunks.flatMap((asyncThunk)=>[\n            asyncThunk.pending,\n            asyncThunk.rejected,\n            asyncThunk.fulfilled\n        ]));\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar externalAbortMessage = \"External signal was aborted\";\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg, { signal } = {}) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                if (signal) {\n                    if (signal.aborted) {\n                        abort(externalAbortMessage);\n                    } else {\n                        signal.addEventListener(\"abort\", ()=>abort(externalAbortMessage), {\n                            once: true\n                        });\n                    }\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler);\n                        });\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        const injectedStateCache = /* @__PURE__ */ new WeakMap();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2, injected = false) {\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors(selectState = selectSelf) {\n                const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, ()=>/* @__PURE__ */ new WeakMap());\n                return getOrInsertComputed(selectorCache, selectState, ()=>{\n                    const map = {};\n                    for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                        map[name2] = wrapSelector(selector, selectState, ()=>getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);\n                    }\n                    return map;\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const newReducerPath = pathOpt ?? reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory(stateAdapter) {\n    function getInitialState(additionalState = {}, entities) {\n        const state = Object.assign(getInitialEntityState(), additionalState);\n        return entities ? stateAdapter.setAll(state, entities) : state;\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\n\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction getCurrent(value) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingIdsArray = getCurrent(state.ids);\n    const existingIds = new Set(existingIdsArray);\n    const added = [];\n    const addedIds = /* @__PURE__ */ new Set([]);\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (existingIds.has(id) || addedIds.has(id)) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            addedIds.add(id);\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated,\n        existingIdsArray\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        ;\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        ;\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id]?.changes,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        addManyMutably(added, state);\n        updateManyMutably(updated, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n    let lowIndex = 0;\n    let highIndex = sortedItems.length;\n    while(lowIndex < highIndex){\n        let middleIndex = lowIndex + highIndex >>> 1;\n        const currentItem = sortedItems[middleIndex];\n        const res = comparisonFunction(item, currentItem);\n        if (res >= 0) {\n            lowIndex = middleIndex + 1;\n        } else {\n            highIndex = middleIndex;\n        }\n    }\n    return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n    const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n    sortedItems.splice(insertAtIndex, 0, item);\n    return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state, existingIds) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n        const models = newEntities.filter((model)=>!existingKeys.has(selectIdValue(model, selectId)));\n        if (models.length !== 0) {\n            mergeFunction(state, models);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            for (const item of newEntities){\n                delete state.entities[selectId(item)];\n            }\n            mergeFunction(state, newEntities);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state, []);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        let replacedIds = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                replacedIds = true;\n                delete state.entities[update.id];\n                const oldIndex = state.ids.indexOf(update.id);\n                state.ids[oldIndex] = newId;\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            mergeFunction(state, [], appliedUpdates, replacedIds);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        if (added.length) {\n            addManyMutably(added, state, existingIdsArray);\n        }\n        if (updated.length) {\n            updateManyMutably(updated, state);\n        }\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    const mergeFunction = (state, addedItems, appliedUpdates, replacedIds)=>{\n        const currentEntities = getCurrent(state.entities);\n        const currentIds = getCurrent(state.ids);\n        const stateEntities = state.entities;\n        let ids = currentIds;\n        if (replacedIds) {\n            ids = new Set(currentIds);\n        }\n        let sortedEntities = [];\n        for (const id of ids){\n            const entity = currentEntities[id];\n            if (entity) {\n                sortedEntities.push(entity);\n            }\n        }\n        const wasPreviouslyEmpty = sortedEntities.length === 0;\n        for (const item of addedItems){\n            stateEntities[selectId(item)] = item;\n            if (!wasPreviouslyEmpty) {\n                insert(sortedEntities, item, comparer);\n            }\n        }\n        if (wasPreviouslyEmpty) {\n            sortedEntities = addedItems.slice().sort(comparer);\n        } else if (appliedUpdates) {\n            sortedEntities.sort(comparer);\n        }\n        const newSortedIds = sortedEntities.map(selectId);\n        if (!areArraysEqual(currentIds, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    };\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    const stateFactory = createInitialStateFactory(stateAdapter);\n    const selectorsFactory = createSelectorsFactory();\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new TypeError( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const entry = {\n        id: nanoid(),\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar findListenerEntry = (listenerMap, options)=>{\n    const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n    return Array.from(listenerMap.values()).find((entry)=>{\n        const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\n        return matchPredicateOrType && entry.effect === effect;\n    });\n};\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {})=>{\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\n        return insertEntry(entry);\n    };\n    assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const entry = findListenerEntry(listenerMap, options);\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>getOrInsertComputed(entry.applied, api, entry.middleware));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap, initialStateCache)=>getOrInsertComputed(stateProxyMap, state, ()=>new Proxy(state, {\n            get: (target, prop, receiver)=>{\n                if (prop === ORIGINAL_STATE) return target;\n                const result = Reflect.get(target, prop, receiver);\n                if (typeof result === \"undefined\") {\n                    const cached = initialStateCache[prop];\n                    if (typeof cached !== \"undefined\") return cached;\n                    const reducer = reducerMap[prop];\n                    if (reducer) {\n                        const reducerResult = reducer(void 0, {\n                            type: nanoid()\n                        });\n                        if (typeof reducerResult === \"undefined\") {\n                            throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                        }\n                        initialStateCache[prop] = reducerResult;\n                        return reducerResult;\n                    }\n                }\n                return result;\n            }\n        }));\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nvar emptyObject = {};\nvar noopReducer = (state = emptyObject)=>state;\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const initialStateCache = {};\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        if (config.overrideExisting && currentReducer !== reducerToInject) {\n            delete initialStateCache[reducerPath];\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDLENBQUMsR0FBR0M7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE1BQU1FLDJCQUEyQkMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0M7UUFDakQsTUFBTUMsV0FBV0wsbUJBQW1CSTtRQUNwQyxNQUFNRSxrQkFBa0IsQ0FBQ0MsT0FBTyxHQUFHQyxPQUFTSCxTQUFTZiw4Q0FBT0EsQ0FBQ2lCLFNBQVN0Qiw4Q0FBT0EsQ0FBQ3NCLFNBQVNBLFVBQVVDO1FBQ2pHTixPQUFPQyxNQUFNLENBQUNHLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVCxHQUFHO1FBQ0RHLFdBQVcsSUFBTVI7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSVMsMEJBQTBCLGFBQWEsR0FBR1osK0JBQStCRixvREFBY0E7QUFFM0Ysd0JBQXdCO0FBQ29HO0FBRTVILDJCQUEyQjtBQUNLO0FBQ2hDLElBQUlzQixzQkFBc0IsTUFBNEUsR0FBR0MsQ0FBMkMsR0FBRztJQUNySixJQUFJRSxVQUFVQyxNQUFNLEtBQUssR0FBRyxPQUFPLEtBQUs7SUFDeEMsSUFBSSxPQUFPRCxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVUsT0FBT1IsMENBQU9BO0lBQ3BELE9BQU9BLDBDQUFPQSxDQUFDVSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNBQVNPLEtBQUs7UUFDbkIsT0FBT0E7SUFDVDtBQUNGO0FB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QU9rUixnQkFBZ0IsSUFBSUQsa0JBQWtCQSxtQkFBbUJELGlCQUFpQjtZQUNwRixJQUFJLE9BQU8vbkIsWUFBWSxlQUFlQSxrQkFBeUIsZUFBZTtnQkFDNUVzQixRQUFRbEIsS0FBSyxDQUFDLENBQUMsdURBQXVELEVBQUUrVCxZQUFZLDhDQUE4QyxDQUFDO1lBQ3JJO1lBQ0EsT0FBTzBUO1FBQ1Q7UUFDQSxJQUFJOVEsT0FBT2tSLGdCQUFnQixJQUFJRCxtQkFBbUJELGlCQUFpQjtZQUNqRSxPQUFPZixpQkFBaUIsQ0FBQzdTLFlBQVk7UUFDdkM7UUFDQTRTLFVBQVUsQ0FBQzVTLFlBQVksR0FBRzRUO1FBQzFCeGMsVUFBVXFjO1FBQ1YsT0FBT0M7SUFDVDtJQUNBLE1BQU1ocUIsV0FBV0gsT0FBT0MsTUFBTSxDQUFDLFNBQVN1cUIsYUFBYUMsVUFBVSxFQUFFNVIsV0FBVztRQUMxRSxPQUFPLFNBQVM2UixVQUFVbmhCLEtBQUssRUFBRSxHQUFHMUosSUFBSTtZQUN0QyxPQUFPNHFCLFdBQVdyQixpQkFBaUJ2USxjQUFjQSxZQUFZdFAsVUFBVTFKLFFBQVEwSixPQUFPOGYsWUFBWUMsdUJBQXVCenBCO1FBQzNIO0lBQ0YsR0FBRztRQUNEWDtJQUNGO0lBQ0EsT0FBT2MsT0FBT0MsTUFBTSxDQUFDa3FCLGlCQUFpQjtRQUNwQzVRO1FBQ0FwWjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU29DLHVCQUF1QnFmLElBQUk7SUFDbEMsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLGlEQUFpRCxFQUFFQSxLQUFLLCtFQUErRSxDQUFDO0FBQ3ZMO0FBb0RFLENBQ0YsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmVhc3RpZC1sYW5kaW5nLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MywgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDUgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIFR1cGxlID0gY2xhc3MgX1R1cGxlIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1R1cGxlLnByb3RvdHlwZSk7XG4gIH1cbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgIHJldHVybiBfVHVwbGU7XG4gIH1cbiAgY29uY2F0KC4uLmFycikge1xuICAgIHJldHVybiBzdXBlci5jb25jYXQuYXBwbHkodGhpcywgYXJyKTtcbiAgfVxuICBwcmVwZW5kKC4uLmFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyci5jb25jYXQodGhpcykpO1xuICB9XG59O1xuZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlKHZhbCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkKG1hcCwga2V5LCBjb21wdXRlKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSk7XG4gIHJldHVybiBtYXAuc2V0KGtleSwgY29tcHV0ZShrZXkpKS5nZXQoa2V5KTtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGRlY3ljbGVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpIGNhY2hlLmFkZCh2YWx1ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTmVzdGVkRnJvemVuKHZhbHVlKSB7XG4gIGlmICghT2JqZWN0LmlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgYXV0b0JhdGNoRW5oYW5jZXIgPSAob3B0aW9ucyA9IHtcbiAgdHlwZTogXCJyYWZcIlxufSkgPT4gKG5leHQpID0+ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gbmV4dCguLi5hcmdzKTtcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XG4gIGxldCBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xuICBsZXQgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSBvcHRpb25zLnR5cGUgPT09IFwidGlja1wiID8gcXVldWVNaWNyb3Rhc2sgOiBvcHRpb25zLnR5cGUgPT09IFwicmFmXCIgPyAoXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdvbid0IGV4aXN0IGluIFNTUiBlbnZpcm9ubWVudHMuIEZhbGwgYmFjayB0byBhIHZhZ3VlIGFwcHJveGltYXRpb24ganVzdCB0byBrZWVwIGZyb20gZXJyb3JpbmcuXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKVxuICApIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjayA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2spIHtcbiAgICBsZXQgbWlkZGxld2FyZVJlZmVyZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZpbmFsTWlkZGxld2FyZS5mb3JFYWNoKChtaWRkbGV3YXJlMikgPT4ge1xuICAgICAgaWYgKG1pZGRsZXdhcmVSZWZlcmVuY2VzLmhhcyhtaWRkbGV3YXJlMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDIpIDogXCJEdXBsaWNhdGUgbWlkZGxld2FyZSByZWZlcmVuY2VzIGZvdW5kIHdoZW4gY3JlYXRpbmcgdGhlIHN0b3JlLiBFbnN1cmUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgaXMgb25seSBpbmNsdWRlZCBvbmNlLlwiKTtcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVSZWZlcmVuY2VzLmFkZChtaWRkbGV3YXJlMik7XG4gICAgfSk7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcImBlbmhhbmNlcnNgIGZpZWxkIG11c3QgYmUgYSBjYWxsYmFja1wiKTtcbiAgfVxuICBsZXQgc3RvcmVFbmhhbmNlcnMgPSB0eXBlb2YgZW5oYW5jZXJzID09PSBcImZ1bmN0aW9uXCIgPyBlbmhhbmNlcnMoZ2V0RGVmYXVsdEVuaGFuY2VycykgOiBnZXREZWZhdWx0RW5oYW5jZXJzKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUubGVuZ3RoICYmICFzdG9yZUVuaGFuY2Vycy5pbmNsdWRlcyhtaWRkbGV3YXJlRW5oYW5jZXIpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xuICB9XG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMiwgaXNEcmFmdCBhcyBpc0RyYWZ0MiwgaXNEcmFmdGFibGUgYXMgaXNEcmFmdGFibGUyIH0gZnJvbSBcImltbWVyXCI7XG5cbi8vIHNyYy9tYXBCdWlsZGVycy50c1xuZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2soYnVpbGRlckNhbGxiYWNrKSB7XG4gIGNvbnN0IGFjdGlvbnNNYXAgPSB7fTtcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcbiAgbGV0IGRlZmF1bHRDYXNlUmVkdWNlcjtcbiAgY29uc3QgYnVpbGRlciA9IHtcbiAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjcpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZEFzeW5jVGh1bmsoYXN5bmNUaHVuaywgcmVkdWNlcnMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzKSA6IFwiYGJ1aWxkZXIuYWRkQXN5bmNUaHVua2Agc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZHVjZXJzLnBlbmRpbmcpIGFjdGlvbnNNYXBbYXN5bmNUaHVuay5wZW5kaW5nLnR5cGVdID0gcmVkdWNlcnMucGVuZGluZztcbiAgICAgIGlmIChyZWR1Y2Vycy5yZWplY3RlZCkgYWN0aW9uc01hcFthc3luY1RodW5rLnJlamVjdGVkLnR5cGVdID0gcmVkdWNlcnMucmVqZWN0ZWQ7XG4gICAgICBpZiAocmVkdWNlcnMuZnVsZmlsbGVkKSBhY3Rpb25zTWFwW2FzeW5jVGh1bmsuZnVsZmlsbGVkLnR5cGVdID0gcmVkdWNlcnMuZnVsZmlsbGVkO1xuICAgICAgaWYgKHJlZHVjZXJzLnNldHRsZWQpIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyOiBhc3luY1RodW5rLnNldHRsZWQsXG4gICAgICAgIHJlZHVjZXI6IHJlZHVjZXJzLnNldHRsZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9tYXRjaGVycy50c1xudmFyIG1hdGNoZXMgPSAobWF0Y2hlciwgYWN0aW9uKSA9PiB7XG4gIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xuICB9XG59O1xuZnVuY3Rpb24gaXNBbnlPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBbGxPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5ldmVyeSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgdmFsaWRTdGF0dXMpIHtcbiAgaWYgKCFhY3Rpb24gfHwgIWFjdGlvbi5tZXRhKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSk7XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpKTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLmZ1bGZpbGxlZCkpO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCIsIFwiZnVsZmlsbGVkXCIsIFwicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5mbGF0TWFwKChhc3luY1RodW5rKSA9PiBbYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZF0pKTtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBleHRlcm5hbEFib3J0TWVzc2FnZSA9IFwiRXh0ZXJuYWwgc2lnbmFsIHdhcyBhYm9ydGVkXCI7XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZywge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHt9KSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KGV4dGVybmFsQWJvcnRNZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBhYm9ydChleHRlcm5hbEFib3J0TWVzc2FnZSksIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlscyA9IHtcbiAgICAgICAgcmVkdWNlck5hbWUsXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxuICAgICAgICBjcmVhdGVOb3RhdGlvbjogdHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcbiAgICAgIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0ge1xuICAgICAgICAuLi5leHRyYVJlZHVjZXJzLFxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIob3B0aW9ucy5pbml0aWFsU3RhdGUsIChidWlsZGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihzTS5tYXRjaGVyLCBzTS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0U2VsZiA9IChzdGF0ZSkgPT4gc3RhdGU7XG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpbmplY3RlZFN0YXRlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBsZXQgX3JlZHVjZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aDIsIGluamVjdGVkID0gZmFsc2UpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XG4gICAgICAgIGxldCBzbGljZVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGgyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0T3JJbnNlcnRDb21wdXRlZChpbmplY3RlZFN0YXRlQ2FjaGUsIHNlbGVjdFNsaWNlLCBnZXRJbml0aWFsU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSA9IHNlbGVjdFNlbGYpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICByZXR1cm4gZ2V0T3JJbnNlcnRDb21wdXRlZChzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICBtYXBbbmFtZTJdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgKCkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChpbmplY3RlZFN0YXRlQ2FjaGUsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUpLCBpbmplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuaW1wb3J0IHsgY3VycmVudCBhcyBjdXJyZW50MiwgaXNEcmFmdCBhcyBpc0RyYWZ0NCB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNEcmFmdDQodmFsdWUpID8gY3VycmVudDIodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHNBcnJheSA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzQXJyYXkpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCBhZGRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoZXhpc3RpbmdJZHMuaGFzKGlkKSB8fCBhZGRlZElkcy5oYXMoaWQpKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWRJZHMuYWRkKGlkKTtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZCwgZXhpc3RpbmdJZHNBcnJheV07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xuICAgIHJldHVybiBoYXNOZXdLZXk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBjb25zdCBuZXdLZXlzID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB7XG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0/LmNoYW5nZXMsXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcbiAgICBjb25zdCBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKCh1cGRhdGUpID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XG4gICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpLm1hcCgoZSkgPT4gc2VsZWN0SWRWYWx1ZShlLCBzZWxlY3RJZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgbGV0IGxvd0luZGV4ID0gMDtcbiAgbGV0IGhpZ2hJbmRleCA9IHNvcnRlZEl0ZW1zLmxlbmd0aDtcbiAgd2hpbGUgKGxvd0luZGV4IDwgaGlnaEluZGV4KSB7XG4gICAgbGV0IG1pZGRsZUluZGV4ID0gbG93SW5kZXggKyBoaWdoSW5kZXggPj4+IDE7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBzb3J0ZWRJdGVtc1ttaWRkbGVJbmRleF07XG4gICAgY29uc3QgcmVzID0gY29tcGFyaXNvbkZ1bmN0aW9uKGl0ZW0sIGN1cnJlbnRJdGVtKTtcbiAgICBpZiAocmVzID49IDApIHtcbiAgICAgIGxvd0luZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvd0luZGV4O1xufVxuZnVuY3Rpb24gaW5zZXJ0KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgY29uc3QgaW5zZXJ0QXRJbmRleCA9IGZpbmRJbnNlcnRJbmRleChzb3J0ZWRJdGVtcywgaXRlbSwgY29tcGFyaXNvbkZ1bmN0aW9uKTtcbiAgc29ydGVkSXRlbXMuc3BsaWNlKGluc2VydEF0SW5kZXgsIDAsIGl0ZW0pO1xuICByZXR1cm4gc29ydGVkSXRlbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIGNvbXBhcmVyKSB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVPbmUsXG4gICAgcmVtb3ZlTWFueSxcbiAgICByZW1vdmVBbGxcbiAgfSA9IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIGFkZE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlLCBleGlzdGluZ0lkcykge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gbmV3IFNldChleGlzdGluZ0lkcyA/PyBnZXRDdXJyZW50KHN0YXRlLmlkcykpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICFleGlzdGluZ0tleXMuaGFzKHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKSkpO1xuICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBtb2RlbHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQoaXRlbSldO1xuICAgICAgfVxuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbmV3RW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGxldCByZXBsYWNlZElkcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgcmVwbGFjZWRJZHMgPSB0cnVlO1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBzdGF0ZS5pZHMuaW5kZXhPZih1cGRhdGUuaWQpO1xuICAgICAgICBzdGF0ZS5pZHNbb2xkSW5kZXhdID0gbmV3SWQ7XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBbXSwgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlLCBleGlzdGluZ0lkc0FycmF5KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG4gICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG1lcmdlRnVuY3Rpb24gPSAoc3RhdGUsIGFkZGVkSXRlbXMsIGFwcGxpZWRVcGRhdGVzLCByZXBsYWNlZElkcykgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRFbnRpdGllcyA9IGdldEN1cnJlbnQoc3RhdGUuZW50aXRpZXMpO1xuICAgIGNvbnN0IGN1cnJlbnRJZHMgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XG4gICAgY29uc3Qgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuICAgIGxldCBpZHMgPSBjdXJyZW50SWRzO1xuICAgIGlmIChyZXBsYWNlZElkcykge1xuICAgICAgaWRzID0gbmV3IFNldChjdXJyZW50SWRzKTtcbiAgICB9XG4gICAgbGV0IHNvcnRlZEVudGl0aWVzID0gW107XG4gICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGN1cnJlbnRFbnRpdGllc1tpZF07XG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHNvcnRlZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FzUHJldmlvdXNseUVtcHR5ID0gc29ydGVkRW50aXRpZXMubGVuZ3RoID09PSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGRlZEl0ZW1zKSB7XG4gICAgICBzdGF0ZUVudGl0aWVzW3NlbGVjdElkKGl0ZW0pXSA9IGl0ZW07XG4gICAgICBpZiAoIXdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgICBpbnNlcnQoc29ydGVkRW50aXRpZXMsIGl0ZW0sIGNvbXBhcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgc29ydGVkRW50aXRpZXMgPSBhZGRlZEl0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlcik7XG4gICAgfSBlbHNlIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgc29ydGVkRW50aXRpZXMuc29ydChjb21wYXJlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IHNvcnRlZEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChjdXJyZW50SWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUFkYXB0ZXIgPSBzb3J0Q29tcGFyZXIgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcikgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xudmFyIHZhbGlkYXRlQWN0aXZlID0gKHNpZ25hbCkgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWFzb25cbiAgICB9ID0gc2lnbmFsO1xuICAgIHRocm93IG5ldyBUYXNrQWJvcnRFcnJvcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKSB7XG4gIGxldCBjbGVhbnVwID0gbm9vcDI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgbm90aWZ5UmVqZWN0aW9uID0gKCkgPT4gcmVqZWN0KG5ldyBUYXNrQWJvcnRFcnJvcihzaWduYWwucmVhc29uKSk7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBub3RpZnlSZWplY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYW51cCA9IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xuICAgIHByb21pc2UuZmluYWxseSgoKSA9PiBjbGVhbnVwKCkpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgY2xlYW51cCA9IG5vb3AyO1xuICB9KTtcbn1cbnZhciBydW5UYXNrID0gYXN5bmMgKHRhc2syLCBjbGVhblVwKSA9PiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrMigpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwib2tcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBlcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yID8gXCJjYW5jZWxsZWRcIiA6IFwicmVqZWN0ZWRcIixcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhblVwPy4oKTtcbiAgfVxufTtcbnZhciBjcmVhdGVQYXVzZSA9IChzaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gIH07XG59O1xudmFyIGNyZWF0ZURlbGF5ID0gKHNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlKHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XG4gICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciB7XG4gIGFzc2lnblxufSA9IE9iamVjdDtcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcbnZhciBhbG0gPSBcImxpc3RlbmVyTWlkZGxld2FyZVwiO1xudmFyIGNyZWF0ZUZvcmsgPSAocGFyZW50QWJvcnRTaWduYWwsIHBhcmVudEJsb2NraW5nUHJvbWlzZXMpID0+IHtcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XG4gIHJldHVybiAodGFza0V4ZWN1dG9yLCBvcHRzKSA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCBcInRhc2tFeGVjdXRvclwiKTtcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsaW5rQ29udHJvbGxlcnMoY2hpbGRBYm9ydENvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRhc2soYXN5bmMgKCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXNrRXhlY3V0b3Ioe1xuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIHNpZ25hbDogY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHM/LmF1dG9Kb2luKSB7XG4gICAgICBwYXJlbnRCbG9ja2luZ1Byb21pc2VzLnB1c2gocmVzdWx0LmNhdGNoKG5vb3AyKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICBjb25zdCBlbnRyeSA9IHtcbiAgICBpZDogbmFub2lkKCksXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZUxpc3RlbmVyRW50cnlcbn0pO1xudmFyIGZpbmRMaXN0ZW5lckVudHJ5ID0gKGxpc3RlbmVyTWFwLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGVmZmVjdCxcbiAgICBwcmVkaWNhdGVcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKS5maW5kKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeS50eXBlID09PSB0eXBlIDogZW50cnkucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5LmVmZmVjdCA9PT0gZWZmZWN0O1xuICB9KTtcbn07XG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gKGVudHJ5KSA9PiB7XG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICB9KTtcbn07XG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXApID0+IHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XG4gICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcbiAgfTtcbn07XG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pID0+IHtcbiAgdHJ5IHtcbiAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcbiAgfSBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGVycm9ySGFuZGxlckVycm9yO1xuICAgIH0sIDApO1xuICB9XG59O1xudmFyIGFkZExpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vYWRkYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBhZGRMaXN0ZW5lclxufSk7XG52YXIgY2xlYXJBbGxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IHJlbW92ZUxpc3RlbmVyXG59KTtcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5lcnJvcihgJHthbG19L2Vycm9yYCwgLi4uYXJncyk7XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSA9IChtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkobGlzdGVuZXJNYXAsIG9wdGlvbnMpID8/IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucyk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIG1pZGRsZXdhcmUsXG4gIGFwcGxpZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbn0pO1xudmFyIG1hdGNoSW5zdGFuY2UgPSAoaW5zdGFuY2VJZCkgPT4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xudmFyIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZUlkID0gbmFub2lkKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB3aXRoTWlkZGxld2FyZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlQWN0aW9uKFwiZHluYW1pY01pZGRsZXdhcmUvYWRkXCIsICguLi5taWRkbGV3YXJlcykgPT4gKHtcbiAgICBwYXlsb2FkOiBtaWRkbGV3YXJlcyxcbiAgICBtZXRhOiB7XG4gICAgICBpbnN0YW5jZUlkXG4gICAgfVxuICB9KSksIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHdpdGhNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlMiguLi5taWRkbGV3YXJlcykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goKG1pZGRsZXdhcmUyKSA9PiB7XG4gICAgICBnZXRPckluc2VydENvbXB1dGVkKG1pZGRsZXdhcmVNYXAsIG1pZGRsZXdhcmUyLCBjcmVhdGVNaWRkbGV3YXJlRW50cnkpO1xuICAgIH0pO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBhZGRNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBnZXRGaW5hbE1pZGRsZXdhcmUgPSAoYXBpKSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcCgoZW50cnkpID0+IGdldE9ySW5zZXJ0Q29tcHV0ZWQoZW50cnkuYXBwbGllZCwgYXBpLCBlbnRyeS5taWRkbGV3YXJlKSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCwgaW5pdGlhbFN0YXRlQ2FjaGUpID0+IGdldE9ySW5zZXJ0Q29tcHV0ZWQoc3RhdGVQcm94eU1hcCwgc3RhdGUsICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgaWYgKHByb3AgPT09IE9SSUdJTkFMX1NUQVRFKSByZXR1cm4gdGFyZ2V0O1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCBjYWNoZWQgPSBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgY2FjaGVkICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY2FjaGVkO1xuICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcF07XG4gICAgICBpZiAocmVkdWNlcikge1xuICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICB0eXBlOiBuYW5vaWQoKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjQpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke3Byb3AudG9TdHJpbmcoKX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBjYWxsZWQgZm9yIHNlbGVjdG9yKCkuIElmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIHlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFN0YXRlQ2FjaGVbcHJvcF0gPSByZWR1Y2VyUmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVkdWNlclJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSkpO1xudmFyIG9yaWdpbmFsID0gKHN0YXRlKSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI1KSA6IFwib3JpZ2luYWwgbXVzdCBiZSB1c2VkIG9uIHN0YXRlIFByb3h5XCIpO1xuICB9XG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XG59O1xudmFyIGVtcHR5T2JqZWN0ID0ge307XG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSBlbXB0eU9iamVjdCkgPT4gc3RhdGU7XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xuICBsZXQgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG4gIGNvbnN0IGluaXRpYWxTdGF0ZUNhY2hlID0ge307XG4gIGNvbnN0IGluamVjdCA9IChzbGljZSwgY29uZmlnID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuICAgIGlmIChjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBkZWxldGUgaW5pdGlhbFN0YXRlQ2FjaGVbcmVkdWNlclBhdGhdO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXAsIGluaXRpYWxTdGF0ZUNhY2hlKSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfSwge1xuICAgIG9yaWdpbmFsXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21iaW5lZFJlZHVjZXIsIHtcbiAgICBpbmplY3QsXG4gICAgc2VsZWN0b3JcbiAgfSk7XG59XG5cbi8vIHNyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cbmV4cG9ydCB7XG4gIFJlZHVjZXJUeXBlLFxuICBTSE9VTERfQVVUT0JBVENILFxuICBUYXNrQWJvcnRFcnJvcixcbiAgVHVwbGUsXG4gIGFkZExpc3RlbmVyLFxuICBhc3luY1RodW5rQ3JlYXRvcixcbiAgYXV0b0JhdGNoRW5oYW5jZXIsXG4gIGJ1aWxkQ3JlYXRlU2xpY2UsXG4gIGNsZWFyQWxsTGlzdGVuZXJzLFxuICBjb21iaW5lU2xpY2VzLFxuICBjb25maWd1cmVTdG9yZSxcbiAgY3JlYXRlQWN0aW9uLFxuICBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlQXN5bmNUaHVuayxcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IsXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUsXG4gIGNyZWF0ZUVudGl0eUFkYXB0ZXIsXG4gIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlLFxuICBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSxcbiAgY3JlYXRlUmVkdWNlcixcbiAgY3JlYXRlU2VsZWN0b3IsXG4gIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZVNsaWNlLFxuICBjdXJyZW50MyBhcyBjdXJyZW50LFxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsXG4gIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UsXG4gIGZyZWV6ZSxcbiAgaXNBY3Rpb25DcmVhdG9yLFxuICBpc0FsbE9mLFxuICBpc0FueU9mLFxuICBpc0FzeW5jVGh1bmtBY3Rpb24sXG4gIGlzRHJhZnQ1IGFzIGlzRHJhZnQsXG4gIGlzRlNBIGFzIGlzRmx1eFN0YW5kYXJkQWN0aW9uLFxuICBpc0Z1bGZpbGxlZCxcbiAgaXNJbW11dGFibGVEZWZhdWx0LFxuICBpc1BlbmRpbmcsXG4gIGlzUGxhaW4sXG4gIGlzUmVqZWN0ZWQsXG4gIGlzUmVqZWN0ZWRXaXRoVmFsdWUsXG4gIGxydU1lbW9pemUsXG4gIG1pbmlTZXJpYWxpemVFcnJvcixcbiAgbmFub2lkLFxuICBvcmlnaW5hbDIgYXMgb3JpZ2luYWwsXG4gIHByZXBhcmVBdXRvQmF0Y2hlZCxcbiAgcmVtb3ZlTGlzdGVuZXIsXG4gIHVud3JhcFJlc3VsdCxcbiAgd2Vha01hcE1lbW9pemUyIGFzIHdlYWtNYXBNZW1vaXplXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6WyJwcm9kdWNlIiwiY3VycmVudCIsImN1cnJlbnQzIiwiZnJlZXplIiwib3JpZ2luYWwiLCJvcmlnaW5hbDIiLCJpc0RyYWZ0IiwiaXNEcmFmdDUiLCJjcmVhdGVTZWxlY3RvciIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvciIsImNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIiLCJscnVNZW1vaXplIiwid2Vha01hcE1lbW9pemUiLCJ3ZWFrTWFwTWVtb2l6ZTIiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IiLCJhcmdzIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyIiwiT2JqZWN0IiwiYXNzaWduIiwiYXJnczIiLCJzZWxlY3RvciIsIndyYXBwZWRTZWxlY3RvciIsInZhbHVlIiwicmVzdCIsIndpdGhUeXBlcyIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yIiwiYXBwbHlNaWRkbGV3YXJlIiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJjb21iaW5lUmVkdWNlcnMiLCJpc1BsYWluT2JqZWN0IiwiaXNQbGFpbk9iamVjdDIiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJkZXZUb29sc0VuaGFuY2VyIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsIm5vb3AzIiwidGh1bmsiLCJ0aHVua01pZGRsZXdhcmUiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImlzQWN0aW9uIiwiaGFzTWF0Y2hGdW5jdGlvbiIsInYiLCJtYXRjaCIsImNyZWF0ZUFjdGlvbiIsInR5cGUiLCJwcmVwYXJlQWN0aW9uIiwiYWN0aW9uQ3JlYXRvciIsInByZXBhcmVkIiwiRXJyb3IiLCJwcm9jZXNzIiwiZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsInBheWxvYWQiLCJtZXRhIiwiZXJyb3IiLCJ0b1N0cmluZyIsImFjdGlvbiIsImlzQWN0aW9uQ3JlYXRvciIsImlzRlNBIiwia2V5cyIsImV2ZXJ5IiwiaXNWYWxpZEtleSIsImtleSIsImluZGV4T2YiLCJnZXRNZXNzYWdlIiwic3BsaXRUeXBlIiwic3BsaXQiLCJhY3Rpb25OYW1lIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwibmV4dCIsImlzQWN0aW9uQ3JlYXRvcjIiLCJjb25zb2xlIiwid2FybiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRHJhZnRhYmxlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJUdXBsZSIsIl9UdXBsZSIsIkFycmF5IiwiY29uc3RydWN0b3IiLCJpdGVtcyIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiU3ltYm9sIiwic3BlY2llcyIsImNvbmNhdCIsImFyciIsInByZXBlbmQiLCJpc0FycmF5IiwiZnJlZXplRHJhZnRhYmxlIiwidmFsIiwiZ2V0T3JJbnNlcnRDb21wdXRlZCIsIm1hcCIsImNvbXB1dGUiLCJoYXMiLCJnZXQiLCJzZXQiLCJpc0ltbXV0YWJsZURlZmF1bHQiLCJpc0Zyb3plbiIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiY2FsbCIsImdldFNlcmlhbGl6ZSIsIndhcm5BZnRlciIsInRyYWNrIiwiYmluZCIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzQWN0aW9uMiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJleHRyYUFyZ3VtZW50IiwiaW1tdXRhYmxlT3B0aW9ucyIsInVuc2hpZnQiLCJzZXJpYWxpemFibGVPcHRpb25zIiwiYWN0aW9uQ3JlYXRvck9wdGlvbnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsImF1dG9CYXRjaEVuaGFuY2VyIiwic3RvcmUiLCJub3RpZnlpbmciLCJzaG91bGROb3RpZnlBdEVuZE9mVGljayIsIm5vdGlmaWNhdGlvblF1ZXVlZCIsImxpc3RlbmVycyIsInF1ZXVlQ2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXVlTm90aWZpY2F0aW9uIiwibm90aWZ5TGlzdGVuZXJzIiwiZm9yRWFjaCIsImwiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lcjIiLCJ3cmFwcGVkTGlzdGVuZXIiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImRpc3BhdGNoIiwiYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzIiwibWlkZGxld2FyZUVuaGFuY2VyIiwiZ2V0RGVmYXVsdEVuaGFuY2VycyIsImF1dG9CYXRjaCIsImVuaGFuY2VyQXJyYXkiLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2siLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVSZWZlcmVuY2VzIiwibWlkZGxld2FyZTIiLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiaW5jbHVkZXMiLCJjb21wb3NlZEVuaGFuY2VyIiwiY3JlYXRlTmV4dFN0YXRlMiIsImlzRHJhZnQyIiwiaXNEcmFmdGFibGUyIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRBc3luY1RodW5rIiwiYXN5bmNUaHVuayIsInJlZHVjZXJzIiwicGVuZGluZyIsInJlamVjdGVkIiwiZnVsZmlsbGVkIiwic2V0dGxlZCIsIm1hdGNoZXIiLCJhZGRNYXRjaGVyIiwiYWRkRGVmYXVsdENhc2UiLCJpc1N0YXRlRnVuY3Rpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGUiLCJjYXNlUmVkdWNlcnMiLCJmaWx0ZXIiLCJyZWR1Y2VyMiIsImNyIiwicmVkdWNlIiwicHJldmlvdXNTdGF0ZSIsImNhc2VSZWR1Y2VyIiwiZHJhZnQiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsInJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsInJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImEiLCJpc1BlbmRpbmciLCJhc3luY1RodW5rcyIsImlzUmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJmbGF0TWFwIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiaWQiLCJpIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsInByb3BlcnR5IiwibWVzc2FnZSIsIlN0cmluZyIsImV4dGVybmFsQWJvcnRNZXNzYWdlIiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiYXJnIiwic2VyaWFsaXplRXJyb3IiLCJhYm9ydGVkIiwibmFtZSIsImNvbmRpdGlvbiIsInNpZ25hbCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydEhhbmRsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJwcm9taXNlIiwiZmluYWxBY3Rpb24iLCJjb25kaXRpb25SZXN1bHQiLCJpc1RoZW5hYmxlIiwiYWJvcnRlZFByb21pc2UiLCJQcm9taXNlIiwicmVqZWN0IiwiZ2V0UGVuZGluZ01ldGEiLCJyYWNlIiwicmVzb2x2ZSIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJ0aGVuIiwiZXJyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNraXBEaXNwYXRjaCIsImRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uIiwidW53cmFwIiwidW53cmFwUmVzdWx0IiwiYXN5bmNUaHVua1N5bWJvbCIsImZvciIsImFzeW5jVGh1bmtDcmVhdG9yIiwiUmVkdWNlclR5cGUiLCJSZWR1Y2VyVHlwZTIiLCJnZXRUeXBlIiwiYWN0aW9uS2V5IiwiYnVpbGRDcmVhdGVTbGljZSIsImNyZWF0b3JzIiwiY0FUIiwiY3JlYXRlU2xpY2UyIiwicmVkdWNlclBhdGgiLCJidWlsZFJlZHVjZXJDcmVhdG9ycyIsInJlZHVjZXJOYW1lcyIsImNvbnRleHQiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSIsInNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlIiwiYWN0aW9uQ3JlYXRvcnMiLCJzbGljZU1hdGNoZXJzIiwiY29udGV4dE1ldGhvZHMiLCJleHBvc2VBY3Rpb24iLCJuYW1lMiIsImV4cG9zZUNhc2VSZWR1Y2VyIiwicmVkdWNlck5hbWUiLCJyZWR1Y2VyRGVmaW5pdGlvbiIsInJlZHVjZXJEZXRhaWxzIiwiY3JlYXRlTm90YXRpb24iLCJpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24iLCJoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbiIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsInNNIiwibSIsInNlbGVjdFNlbGYiLCJpbmplY3RlZFNlbGVjdG9yQ2FjaGUiLCJNYXAiLCJpbmplY3RlZFN0YXRlQ2FjaGUiLCJXZWFrTWFwIiwiX3JlZHVjZXIiLCJtYWtlU2VsZWN0b3JQcm9wcyIsInJlZHVjZXJQYXRoMiIsImluamVjdGVkIiwic2VsZWN0U2xpY2UiLCJzbGljZVN0YXRlIiwiZ2V0U2VsZWN0b3JzIiwic2VsZWN0U3RhdGUiLCJzZWxlY3RvckNhY2hlIiwic2VsZWN0b3JzIiwid3JhcFNlbGVjdG9yIiwiYWN0aW9ucyIsImluamVjdEludG8iLCJpbmplY3RhYmxlIiwicGF0aE9wdCIsImNvbmZpZyIsIm5ld1JlZHVjZXJQYXRoIiwiaW5qZWN0Iiwid3JhcHBlciIsInJvb3RTdGF0ZSIsInVud3JhcHBlZCIsImNyZWF0ZVNsaWNlIiwiX3JlZHVjZXJEZWZpbml0aW9uVHlwZSIsInByZXBhcmVkUmVkdWNlciIsInByZXBhcmUiLCJtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSIsInByZXBhcmVDYWxsYmFjayIsImlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24iLCJub29wIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwiYWRkaXRpb25hbFN0YXRlIiwic2V0QWxsIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJjcmVhdGVOZXh0U3RhdGUzIiwiaXNEcmFmdDMiLCJpc0RyYWZ0VHlwZWQiLCJjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IiLCJtdXRhdG9yIiwib3BlcmF0b3IiLCJjcmVhdGVTdGF0ZU9wZXJhdG9yIiwib3BlcmF0aW9uIiwiaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQiLCJhcmcyIiwicnVuTXV0YXRvciIsImN1cnJlbnQyIiwiaXNEcmFmdDQiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsImdldEN1cnJlbnQiLCJzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzIiwibmV3RW50aXRpZXMiLCJleGlzdGluZ0lkc0FycmF5IiwiZXhpc3RpbmdJZHMiLCJhZGRlZCIsImFkZGVkSWRzIiwidXBkYXRlZCIsImNoYW5nZXMiLCJjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciIsImFkZE9uZU11dGFibHkiLCJhZGRNYW55TXV0YWJseSIsInNldE9uZU11dGFibHkiLCJzZXRNYW55TXV0YWJseSIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMyIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwiZSIsInVwc2VydE9uZU11dGFibHkiLCJ1cHNlcnRNYW55TXV0YWJseSIsInJlbW92ZUFsbCIsImFkZE9uZSIsImFkZE1hbnkiLCJzZXRPbmUiLCJzZXRNYW55IiwidXBkYXRlT25lIiwidXBkYXRlTWFueSIsInVwc2VydE9uZSIsInVwc2VydE1hbnkiLCJyZW1vdmVPbmUiLCJyZW1vdmVNYW55IiwiZmluZEluc2VydEluZGV4Iiwic29ydGVkSXRlbXMiLCJjb21wYXJpc29uRnVuY3Rpb24iLCJsb3dJbmRleCIsImhpZ2hJbmRleCIsIm1pZGRsZUluZGV4IiwiY3VycmVudEl0ZW0iLCJyZXMiLCJpbnNlcnQiLCJpbnNlcnRBdEluZGV4IiwiY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIiwiY29tcGFyZXIiLCJleGlzdGluZ0tleXMiLCJtb2RlbHMiLCJtb2RlbCIsIm1lcmdlRnVuY3Rpb24iLCJhcHBsaWVkVXBkYXRlcyIsInJlcGxhY2VkSWRzIiwibmV3SWQiLCJvbGRJbmRleCIsImFyZUFycmF5c0VxdWFsIiwiYiIsImFkZGVkSXRlbXMiLCJjdXJyZW50RW50aXRpZXMiLCJjdXJyZW50SWRzIiwic3RhdGVFbnRpdGllcyIsInNvcnRlZEVudGl0aWVzIiwid2FzUHJldmlvdXNseUVtcHR5Iiwic29ydCIsIm5ld1NvcnRlZElkcyIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJpc0FjdGlvbjMiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJhc3NlcnRGdW5jdGlvbiIsImZ1bmMiLCJleHBlY3RlZCIsIlR5cGVFcnJvciIsIm5vb3AyIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsImFib3J0Q29udHJvbGxlcldpdGhSZWFzb24iLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbGlkYXRlQWN0aXZlIiwicmFjZVdpdGhTaWduYWwiLCJjbGVhbnVwIiwibm90aWZ5UmVqZWN0aW9uIiwiZmluYWxseSIsInJ1blRhc2siLCJ0YXNrMiIsImNsZWFuVXAiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJJTlRFUk5BTF9OSUxfVE9LRU4iLCJhbG0iLCJjcmVhdGVGb3JrIiwicGFyZW50QWJvcnRTaWduYWwiLCJwYXJlbnRCbG9ja2luZ1Byb21pc2VzIiwibGlua0NvbnRyb2xsZXJzIiwiY29udHJvbGxlciIsInRhc2tFeGVjdXRvciIsIm9wdHMiLCJjaGlsZEFib3J0Q29udHJvbGxlciIsInJlc3VsdDIiLCJkZWxheSIsImF1dG9Kb2luIiwiY2FuY2VsIiwiY3JlYXRlVGFrZVBhdHRlcm4iLCJzdGFydExpc3RlbmluZyIsInRha2UiLCJwcmVkaWNhdGUiLCJ0dXBsZVByb21pc2UiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwicHJvbWlzZXMiLCJnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tIiwiY3JlYXRlTGlzdGVuZXJFbnRyeSIsImVudHJ5IiwiZmluZExpc3RlbmVyRW50cnkiLCJsaXN0ZW5lck1hcCIsImZyb20iLCJmaW5kIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImNsZWFyIiwic2FmZWx5Tm90aWZ5RXJyb3IiLCJlcnJvckhhbmRsZXIiLCJlcnJvclRvTm90aWZ5IiwiZXJyb3JJbmZvIiwiZXJyb3JIYW5kbGVyRXJyb3IiLCJhZGRMaXN0ZW5lciIsImNsZWFyQWxsTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwiY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlIiwibWlkZGxld2FyZU9wdGlvbnMiLCJpbnNlcnRFbnRyeSIsImNhbmNlbE9wdGlvbnMiLCJjYW5jZWxBY3RpdmUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiY29tcG9zZTMiLCJjcmVhdGVNaWRkbGV3YXJlRW50cnkiLCJhcHBsaWVkIiwibWF0Y2hJbnN0YW5jZSIsImluc3RhbmNlSWQiLCJjcmVhdGVEeW5hbWljTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVNYXAiLCJ3aXRoTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiYWRkTWlkZGxld2FyZSIsImFkZE1pZGRsZXdhcmUyIiwiZ2V0RmluYWxNaWRkbGV3YXJlIiwiYXBwbGllZE1pZGRsZXdhcmUiLCJpc1dpdGhNaWRkbGV3YXJlIiwiY29tYmluZVJlZHVjZXJzMiIsImlzU2xpY2VMaWtlIiwibWF5YmVTbGljZUxpa2UiLCJnZXRSZWR1Y2VycyIsInNsaWNlcyIsInNsaWNlT3JNYXAiLCJPUklHSU5BTF9TVEFURSIsImlzU3RhdGVQcm94eSIsInN0YXRlUHJveHlNYXAiLCJjcmVhdGVTdGF0ZVByb3h5IiwicmVkdWNlck1hcCIsImluaXRpYWxTdGF0ZUNhY2hlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiY2FjaGVkIiwicmVkdWNlclJlc3VsdCIsImVtcHR5T2JqZWN0Iiwibm9vcFJlZHVjZXIiLCJjb21iaW5lU2xpY2VzIiwiZnJvbUVudHJpZXMiLCJnZXRSZWR1Y2VyIiwiY29tYmluZWRSZWR1Y2VyIiwid2l0aExhenlMb2FkZWRTbGljZXMiLCJyZWR1Y2VyVG9JbmplY3QiLCJjdXJyZW50UmVkdWNlciIsIm92ZXJyaWRlRXhpc3RpbmciLCJtYWtlU2VsZWN0b3IiLCJzZWxlY3RvckZuIiwic2VsZWN0b3IyIiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;